 02 객체지향형프로그래밍

SCE 논리연산자


부호연산자

double e1 = 3.5;

double e2 = -e1; // 저장된

short num2 = 7;
short num3 = (short)(+num2);
short num4 = (short)(-num2);

num1 = 0
num2 = 0


result = ((num1 += 10) < 0) && ((num2 += 10) > 0);
result = false
num1 = 10
num2 = 0

SCE 쇼트 서킷 이벨류에이션

T && T = T
T && F = F
F && T = F  >  이 경우 앞부분만 봐도 F이기 때문에 뒷부분은 쳐다 보지도 않음
F && F = F  >  이 경우 앞부분만 봐도 F이기 때문에 뒷부분은 쳐다 보지도 않음

그렇기 떄문에 뒤에 연산이 있을경우 뒷연산은 진행되지 않는다 이 부분은 감안을 하고 프로그래밍을 해야한다.

비트를 대상으로 하는 연산
	특별한 경우 쓴다
	public static void main(String[] args) {
		byte n1 = 13;
		byte n2 = 7;
		byte n3 = (byte)(n1 & n2);
		System.out.println(n3);
	}

	연산자 & 는 비트 단위로 AND 연산을 한다.
	연산자 | 은 비트 단위로 OR 연산을 한다.
	연산자 ^ 는 비트 단위로 XOR 연산을 한다.
	연산자 ~는 피연산자의 모든 비트를 반전시켜서 얻은 결과를 반환한다.

비트 쉬프트 연산자
	<< 피 연산자의 비트 열을 왼쪽으로 이동
		빈 공간 0으로 채움
	예) n << 2;
		n의 비트 열으르 두 칸으로 왼쪽으로 이동 시킨 결과 반환
	>> 피연산자의 비트 열을 오른쪽으로 이동
		음수의 경우 1 양수으 ㅣ경우 0으로 채움
	예) n >> 2
		n의 비트 열을 두 칸 오른쪽으로 이동 시킨 결과 반환
	>>> 오른쪽으로 이동하는데 빈 공간을 0으로 채움

		몇칸이동했는지 2의 그 칸 제곱만큼 값이 변함 왼쪽으로 가면 값 증가 오른쪽으로 가면 값 감소

	곱셈, 나눗셈은 부담을 주는 연산을 주기 때문에 저전력, 저클럭이 필요한 프로그래밍에서는
	곱셈, 나눗셈을 쉬프트 연산자를 이용해서 이동한다.
		7을 곱하고 싶으면 (8-1) 왼쪽으로 3번 -만들고 더해준다.



