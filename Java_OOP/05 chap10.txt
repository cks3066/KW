클래스 변수

static 선언을 붙여서 선언하는 클래스 변수

선언된 클래스의 모든 인스턴스가 공유하는 클래스 변수

classs InstCnt {
	static int instNum = 0; // 클래스 변수 (static 변수)

	InstCnt() {
		instNUm++;
		System.out.println("인스턴스 생성: " + instNum);
	}
}

클래스가 공유하는 변수
(전역 변수) 를 클래스 안에 넣고 쓰게됨
객체, 인스턴스에서 쓰는 변수가 아니고
공유 변수라고 생각하면 됩니다.

클래스가 로딩되고 클래스를 읽을때 생성된다.
클래스 인스턴스가 생성될때 만들어지는 것이 아니다.

클래스 또는 인스턴스의 이름을 통해서 접근할 수 있다.

class AccessWay{
	static int num = 0;

	AccessWay() } insrCnt();
	void incrNet(){
		num++;
	}

AccessWay way = new AccessWay(); 1
way.num++; 2
AccessWay.num++; 3

클래스의 이름을 통해서 접근할 수 있다는 것을 알길 바란다.

클래스 변수기 때문에 클래스 이름으로 접근하는 것이 가장 바람직한 방법이라
할수 있겠다.

class InstCnt {
	static int instNUm = 100;
		클래스 변수의 적절한 초기화 위치

클래스 변수의 활용의 예

class Circle {
	static final double PI = 3.1415;
	private double radius;

클래스 메소드의 정의와 호출

static 보이드 쇼 인트
static void showDOUble

외부접근 클래스로 접근할 수 있다.
static을 붙였기떄문에

클래스 메소드에서 인스턴스 변수에 접근이 가능할까?

class AAA {
	int num = 0;
	static void addNum(int n) {
		num += n;
	}	논리적으로 이 문장이 유효할 수 있는지 생각해보자
}

나는 아노딜거 같은데요
왜냐면 인스턴스가 생성이 되어야지 num 이 생성이 되는데
num += n 할떄 num값은 존재하지않는 쓰레기 값이다

스태틱 메소드 안에서 인스턴스 변수를 접근하는 것은 잘못된 방법이다.

System.out.println()

java.lang.System.out.println()

시스템은 자바.lang 패키지에 묶여있는 클래스의 이름
그러나 컴파잉러가 다음 누장을 삽입해 주므로 자바 랭을 생력할 수 있따.

하나의 인스턴스를 스태틱처럼 붙여놔서 사용할 수 있는것이다
static final println() 이런식으로 구성되어 있을것이다.

out은 클래스 System의 이름을 통해 접근하므로
public static void main(STring[] args) {
	static인 이유! 인스턴스 생성과 관계없이 제일 먼저 호출되는 메소드

public인ㅇ 이유! 메인 메소드는 호출 명령 외부로 실행되는 메소드이기 떄문에

main 메소드를 어디에 위치 시킬 것이가

classs Car {
	void myCar() {
	}
 	public static void main(String[] args) {
	
또다른 static 사용

static 초기화 블록

static {
	LocalDate nDate = LocalDate.now();
	date - nDate.toString();
}

class DateOfExcution {
	static String date:;

import static java.lang.Math.PI

System.out.println(Math.PI);



메소드 오버로딩

호출된 메소드를 찾을 때 참조하게 되는 두 가지 정보
- 메소드의 이름
- 메소드의 매개변수

키워드 this를 이용한 다른 생성자의 호출

this 내가 사용하고 있는 지금 이 인스턴스에 대해서
디스를 붙여서 쓰면 간편합니다.

class SimpleBox {
	pricate int data;
	
	Sumple(int data) {
		this.data = data;
	}
} this.data 는 어느 위치에서 건 인스턴스 data를 뜻함

String 인스턴스 생성의 두 가지 방법

String str1 = new String("Simple String");
String str2 = "The Best String";

str1.lenth();

문자열 생성 방법 두가지의 차이점

new로 인스턴스 생성하느냐 바로 넣어주느냐

참조 변수의 참조 값 비교
st1, str2는 동일 인스턴스 참조
str3, str4는 다른 인스턴스 참조

String 인스턴스는 Immutable 인스턴스

String 인스턴스는Inmutanle 인스턴스!

따라서 생성되는 인스턴스 수를 최소화 한다

문자열 연결시키기

class StringConcat
	커피  1
	브레드	2
 		다른공간

	st3= st1.concat(st2)	붙여줘
	커피 + 브래드
			새로운 공간 생성 3

	Strign str4 = "Fresh".concat(st3);
					새로운 공간 + fresh 4

concat 부를떄마다 새로운 공간 생성

문자열의 일부 추출

str.substring(2);
	인덱스 2이후의 내용으로 이루어진 문자열 반환
str.substring(2,4);
	인덱스 2~3에 위치한 내용의 문자열 반환

concat substring equals 같은 str 메소드들을 좀 알아두는게 좋긴하다~

문자열과 기본 자료형의 연산

String birth = (new StringBuilder("양".append(7).append("asd")).toString();

StringBulider stbuf =new StringBuilder("123");

stbuf.append(45678(;

stbuf.deleate(0,2);

subuf.replace(0,3,"AB");

stbuf.reverse();

StringBuffer

StringBuffer와 StringBuilder 기능적으로는 완전히 동일핟.

StringBuffer는 쓰레드에 안전하다
따라서 쓰레드 안전성이 불필요한 상황에서 StirngBuffer를 사용하면 성능저하
그때 StirngBulider 사용