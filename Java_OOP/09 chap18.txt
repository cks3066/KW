자바 가상머신의 메모리 모델

----------------------------------
운영체제 입장에서 자바 가상머신

운영체제의 관점에서는 가상머신도 그냥 프로그램의 하나

운영체제가 4G의 메모리 공간을 할당해준다면
JVM에도 4G 메모리 공간을 할 당

자바 프로그램이 두 개 실행되면, 가상머신도 두 개가 실행된다.
메모장을 두 번 띄우면 두 개의 메모장 프로그램이 실행되는 이치와 같다.

-----------------------------------
자바 가성머신의 메모리 모델

[메소드]metod	메소드의 바이트코드, static 변수	프로그램이 시작되면 생성되고 끝나면 없어진다.
[스택]stack	지역변수, 매개변수	[변수]		{} 안에서 사용되는 변수
[힙]heap		인스턴스 [휘발성]			자바는 인스턴스 위주로 구현된다. 동적인 작업
    - 참조 관계가 끊어진 인스턴스는 접근이 불가! 따라서 가비지 컬렉션의 대상이 된다.
------------------------------------
Object 클래스 finalize 메소드

protected void finalize() throws Throwable

Object 클래스에 정의되어 있는 이 메소드는 인스턴스 소멸 시 자동으로 호출이 된다.
자식 클래스에 오버라이딩 할 수 있음

[이렇게 쓸수 있구나만 알고 넘어가면 됩니다]
?? finalize 와 throws 까먹었당 ㅎㅎ
-----------------------------------
인스턴스의 비교 : equals 메소드

class INum {
 	private int num;
 	public INum(int num) {
 	this.num = num;
 }
 @Override
 public boolean equals(Object obj) {
 	if(this.num == ((INum)obj).num)
 		return true;
 	else
 		return false;
 }
}

public static void main(String[] args) {
	 INum num1 = new INum(10);
	 INum num2 = new INum(12);
	 INum num3 = new INum(10);
	
	 if(num1.equals(num2))
 		System.out.println("num1, num2 내용 동일하다.");
 	else
		 System.out.println("num1, num2 내용 다르다.");

	 if(num1.equals(num3))
 		System.out.println("num1, num3 내용 동일하다.");
	 else
		 System.out.println("num1, num3 내용 다르다.");
}
-----------------------------------------
String 클래스의 equals 메소드

public static void main(String[] args) {
 	String str1 = new String("So Simple");
	 String str2 = new String("So Simple");

	 // 참조 대상을 비교하는 if ~ else문
 	if(str1 == str2)
 		System.out.println("str1, str2 참조 대상 동일하다.");
 	else
 		System.out.println("str1, str2 참조 대상 다르다.");
	
	 // 두 인스턴스 내용 비교하는 if ~ else문
 	if(str1.equals(str2))
		 System.out.println("str1, str2 내용 동일하다.");
	 else
		 System.out.println("str1, str2 내용 다르다.");
}

String 클래스는 내용 비교를 하는 형태로 equals 메소드를 오버라이딩 하고 있음

---------------------------------------------
인스턴스 복사 : clone 메소드

protected Object clone() throws CloneNotSupportedException
Object 클래스에 정의되어 있는 clone 메소드가 호출되면 인스턴스의 복사가 이뤄진다.

클래스 정의 시, clone 메소드의 호출을 허용하려면 Cloneable 인터페이스를 구현해야 한다.
Cloneable 인터페이스는 구현해야 할 추상 메소드가 없는 마커 인터페이스이다.
--------------------------------------------
class Point implements Cloneable {
	 private int xPos;
 	private int yPos;
 
	public Point(int x, int y) {
		 xPos = x;
		 yPos = y;
 }

	 public void showPosition() {
		 System.out.printf("[%d, %d]", xPos, yPos);
		 System.out.println();
 }
 	@Override
 		public Object clone() throws CloneNotSupportedException {
 			return super.clone();   // Object 클래스의 clone 메소드 호출
 }
}

class InstanceCloning {
	 public static void main(String[] args) {
		 Point org = new Point(3, 5);
		 Point cpy;

	 try {
 		cpy = (Point)org.clone();
 		org.showPosition();
 		cpy.showPosition();
 }
	 catch(CloneNotSupportedException e) {
		 e.printStackTrace();
	 }
 }
}

접근 수준 지시자를 proteced에서 public으로 바꾸기 위한 메소드 오버라이딩
------------------------------------------
Shallow Copy 얕은 복사

class Rectangle implements Cloneable {
	private Point unpperLeft;	// 좌측 상단 좌표
	private Point lowerRiget;	// 우측 하단 좌표

	public Recctangle(int x1, int y1, int x2, int y2) {
		upperLeft = new Point(x1, y1);
		lowerRight = new Point(x2, y2);;
	}
	. . . .

	// 얕은 복사
	@Override		
	public Object clone(0 throws CloneNotSupportedException {
		return supper.clone();
	}
	. . . .
}

class Point implements Cloneable {
	private int xPos;
	private int yPos;
	. . . .
	}

public static void main(String[] args) {
	Rectangle org = new Rectangle(1, 1, 9, 9);
	Rectangle cpy;

	try {
		cpy = (Rectangle)org.clone();
		. . . .
	}
	catch(CloneNotSupportedException e) {
		e.printStackTrace();
	}
}

Rectangle 참조변수			Rectangle 인스턴스			Point 인스턴스
	org		->		upperLeft    	 ->	xPos
					lowerRight       -> ＼/  ->	yPos
							 /＼
	cpy		->		upperLeft        ->	/  ＼ ->	xPos
					lowerRight            ->	yPos

진정한 복사가 아니고 참조값만 받은 것
진정한 복사라면 자기 자신만의 공간이 있어야함
---------------------------------
Deep Copy

@Override
public Object clone() throws CloneNotSupportedException {
 	Rectangle copy = (Rectangle)super.clone();

	copy.upperLeft = (Point)upperLeft.clone();
 	copy.lowerRight = (Point)lowerRight.clone();
	
	return copy;
}

//String 대상 [굳이 만들겠다고 한다면]
@Override
public Object clone() throws CloneNotSupportedException {
 	Person cpy = (Person)super.clone(); // clone 메소드 호출을 통한 복사본 생성
 	cpy.name = new String(name); // 깊은 복사의 형태로 복사본을 완성
 	return cpy; // 완성된 복사본의 참조 값 반환
}

Rectangle 참조변수			Rectangle 인스턴스			Point 인스턴스
	org		->		upperLeft    	->	xPos
					lowerRight       	->	yPos
							
	cpy		->		upperLeft        	->	xPos
					lowerRight           ->	yPos

----------------------------------------
19강
기본 자료형의 값을 감싸는 래퍼 클래스

class UseWrapperClass {
	public static void showData(Object obj) {	인스턴스를 요구하는 메소드
		Sysytem.out.println(obj);		이 메소드를 통해서 정수나 실수를 출력하려면
	}					해당 값을 인스턴스화 해야 한다.

	public static void main(String[] args) {
		Interger iInst = new Integer(3);
		showData(iTnst);
		showData(new Double(7.15));
	}
}
이렇듯 기본 자료형의 값을 인스턴스로 감싸는 목적의 클래스를 가리켜 래퍼 클래스라 한다.

-------------------------------------------
래퍼 클래스의 종류
Boolean, Character, Byte, Short, Integer, Long, Float, Double
------------------------------------------
래퍼 클래스의 두 가지 기능
기본 자료형의 값 -> Wrapper 인스턴스 [박싱]
Wrapper 인스턴스 -> 기본 자료형의 값 [언박싱]
------------------------------------------
Integer iObj = new Integer(10); // 박싱
int num = iObj.intValue();	// 언박싱
// 래퍼 인스턴스 값의 증가 방법
iObj = new Interger(iObj.intValue() + 10);
--------------------------------------------
언박싱 메소드는
intValue , doubleValue() 처럼 Value() 를 붙여줌
--------------------------------------------
오토 박싱과 오토 언박싱
Integer iObj = new Integer(10); 하기 귀찮으니깐
Integer iObj = 10;	// 이런식으로 오토 박싱을 한다.

int num = iObj.intValue(); 이렇게 하기 귀찬으니깐
int num = iObj; // 이렇게 오토 언박싱을 한다.

Integer num = 10;
num++;	// new Integer(num.intValue() + 1);
num += 3;	// new Interger(num.intValue() + 3);

int r = num + 5
Integer rObj = num - 5;

-----------------------------------------
Number 클래스
java.lang.Number	모든 래퍼 클래스가 상속하는 클래스

java.lang.Number에 정의된 추상 메소드들
public abstract int intValue()
public abstract long longValue()
public abstract double doubleValue()
--------------------------------------------
valueOf(5);	// 숫자 기반 Integer 인스턴스 생성
max, min, sum
toBinaryString(12)
toOctalString(12)
toHexString(12)
--------------------------------------------
BigInteger, BigDecimal 클래스
엄청 큰 값을 위한 BigInteger
BigInteger big = new BigInteger("100000000000000000000000000");
쌍따옴표로 문자열로 받아들이는 수밖에 저렇게 큰 값을 처리할 수 밖에 없다.

int num = r1.intValueExact()

오차없는 실수 표현을 위한 BigDecimal
BigDecimal d1 = new BigDecimal("1.6");
---------------------------------------------
Math 클래스와 난수의 생성 그리고 문자열 토근의 구분

Math 클래스

Math.PI
Math.sqrt(2)
Math.toDegrees(Math.PI)
Math.sin(radian45)
Math.cos(radian45)
Math.tan(radian45)
Math.log(25)
Math.pow(2,16) 2의 16승

난수의 생성

Random rand = new Random();
	nextBoolean, nextInt, nextLong, nextInt(int bound) 0부터 bound 까지의 랜덤 int, 
	nextFloat// 0.0 ~ 1.0 , nextDouble // 0.0 ~ 1.0
 다른 언어와 반대로 씨드값을 넣어야 같은 난수를 얻을 수 있다.

-------------------------------------------------------------------
"PM:08:45"
	이 문자열의 구분자가 : 일 경우 토큰은 다음 세 가지
	PM	08	45

위와 같이 톸큰을 나누는 방법
StringTokenizer st = new StringTokenizer("PM:08:45", ":");
	public boolean hasMoreTokens 반환할 토큰이 남아 있는가?
	public String nextToken(0	    다음 토큰을 반환

	new StringTokenizer("12 + 36 - 8 / 2 = 44", "+-/* ");
	둘 이상의 구분자! 공백도 구분자에 포함

---------------------------------------------------------
Array 클래스의 배열 복사 메소드

public static int[] copyOf(int[] original, int newLengh)
	--> original에 전달된 배열을 첫 번째 요소부터 newLength의 길이 만큼 복사

public static int[] copyOfRange(int[] original, int from, int to)
	--> original에 전달된 배열을 인덱서 from부터 to 이전 요소까지 복사

public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
	--> 배열 src의 srcPos 에서 배열 dest의 destPost로 length 길이만큼 복사

copyOf
public static void main(String[] args) {
	 double[] arOrg = {1.1, 2.2, 3.3, 4.4, 5.5};

 	// 배열 전체를 복사
 	double[] arCpy1 = Arrays.copyOf(arOrg, arOrg.length);

 	// 세번째 요소까지만 복사
 	double[] arCpy2 = Arrays.copyOf(arOrg, 3);

 	for(double d : arCpy1)
 		System.out.print(d + "\t");
 	System.out.println();

 	for(double d : arCpy2)
 		System.out.print(d + "\t");
	 System.out.println();
}

arraycopy
public static void main(String[] args) {
 	double[] org = {1.1, 2.2, 3.3, 4.4, 5.5};
 	double[] cpy = new double[3];

	// 배열 org의 인덱스 1에서 배열 cpy 인덱스 0으로 세 개의 요소 복사
 	System.arraycopy(org, 1, cpy, 0, 3);

 	for(double d : cpy)
 		System.out.print(d + "\t");
 	System.out.println();
}	

--------------------------------------------
두 배열의 내용 비교

public static boolean equals(int[] a, int[] a2)
	-> 매개변수 a와 a2로 전달된 배열의 내용을 비교하여 true또는 false 반환

public static void main(String[] args) {
	 int[] ar1 = {1, 2, 3, 4, 5};
	 int[] ar2 = Arrays.copyOf(ar1, ar1.length);
	 System.out.println(Arrays.equals(ar1, ar2));
}

인스턴스 일때는 오버라이딩을 통해 비교해야한다.
--------------------------------------------------
sort 메소드
public static void sort(int[] a)
	-> 매개변수 a로 전달된 배열을 오름차순으로 정렬

--------------------------------------------------
인스턴스에대한 오름차순 정렬?
-> 클래스를 정의할 때 오름차순 순서상 크고 작음에 대한 기준을 정희해야 한다.

그러기위해
compareTo 메소드 정의

interface Comparable
	-> int compareTo(Object o)

인자로 전달된 o가 작다면 양의 정수 반환
인자로 전달된 o가 크다면 음의 정수 반환 
인자로 전달된 o와 같다면 o을 반환

class Person implements Comparable {
 	private String name;
 	Private int age;

	 . . . .
 	@Override
	 public int compareTo(Object o) {
 		Person p = (Person)o;
 		if(this.age > p.age)
			 return 1; // 인자로 전달된 o가 작다면 양의 정수 반환
 		else if(this.age < p.age)
 			return -1; // 인자로 전달된 o가 크다면 음의 정수 반환
 		else
 			return 0; // 인자로 전달된 o와 같다면 0을 반환
	 }
 	 . . . .
}

다음과 같이 구현도 가능!
A-B
public int compareTo(Object o) {
	 Person p = (Person)o;
	 return this.age - p.age;
}

------------------------------------------------
배열의 탐색 : 기본 자료형 값 대상
public static int binarySearch(int[] a, int key)
→ 배열 a에서 key를 찾아서 있으면 key의 인덱스 값, 없으면 0보다 작은 수 반환

binarySearch는 이진 탐색을 진행!
 그리고 이진 탐색을 위해서는 탐색 이전에 데이터들이 오름차순으로 정렬되어 있어야 한다. 

--------------------------------------------------
배열의 탐색: 인스턴스 대상
public static int binarySearch(Object[] a, Object key)

마찬가지로 탐색 대상들은 오름차순으로 정렬되어 있어야 한다.
 	그리고 탐색 대상의 확인 여부는 compareTo 메소드의 호출 결과를 근거로 한다.
 	즉, 탐색 방식은 인스턴스의 내용 비교이다! 