클래스 = 데이터 + 기능

재사용성

인스턴스 변수
	클래스 내에 선언된 변수
인스턴스 메소드
	클래스 내에 정의된 메소드

class BankAccount {
	// 인스턴스 변수
	int balance = 0;
	
	// 인스턴스 메소드
	public int deposit(int amount) { ... }
	public int withraw(int 머아문드)
	}

new BankAccount();	// BankAccount 인스턴스 1
new BankAccount();	// BankAccount 인스턴스 2

new를 이용해서 클래스를 불러온다는것
그것을 기억해야 하는것

아무것도 없이 그냥 들어가있습니다. 참조변수가 필요하다는 것이죠

인스턴스와 참조변수

BankAccount myAcnt1;	// 참조변수 myAcnt1 선언
BankAccount myACnt2; 	// 참조변수 myAcnt2 선언

myAcnt1 = new BankAccount();	// myAcnt1이 새로 생성되는 인스턴스를 가리킴
myAcnt2 = new BankAccount(); 	// myAcnt2이 새로 생성되는 인스턴슬 ㄹ가리킴

myAcnt1.deposit(1000);	// myAcnt1이 참조하는 인스턴스의 deposit 호출

-------------- 그니깐 c++에서
BankACcount myAcnt1 을 부르면 그냥 불러와지는데
여기서는 인스턴스를 이용하고 참조변수와 연결해야된다
직접 엑세스를 하지 않는다는 것이죠
C에서는 직접 엑세스를 하는 것이다. 자바는 위험반영을 하지 않기위해 하는 것
포인터와 같은 개념이 아니고 다닞 그냥 참조한다고 생각하면 되겠습니ㅏㄷ.

public과 private을 깔끔하게 쓰는법도 잠깐 살펴보긴 해야할거같아요

변수 =/ 상수

변수가 가리키는 값을 바꿀 수 있다.

뱅크어카운트 ref1 = 뉴 뱅크어카운드();
뱅크어카운트 ref2 = ref1;	// 같은 인스턴스 참조

뱅크어카운트 윤 = 뉴 뱅크어카운트();
.....
윤 = 뉴 뱅크어카운트();	// 윤이 새 인스턴스를 참조해도
직접 내가 정리하지않아도 GC 가 처리해준다 없애준다

하나의 인스턴스를 두개의 변수가 가리키고 있기떄문에
ref1을 사용하든 ref2 를 사용하든 
이 값이 저장되는 저장공간은 하나이다.

출력시 동일한 값을 출력할 것이다.

이렇게 쓸수도 있어요

check(ref); 를 받을 수도 있는데

public static void check(BankAccount acc){
	acc.checkMyBalance();
	} // 복사본이 아니라 참조하는것 래퍼런드 참조

참조변수에 null 에 대입

ref1 = null; 	// ref가 참조하는 인스턴스와의 관계를 끊음

생성자와 string 클래스

리터럴 상수

String 클래스에 대한 첫 소개

public static void main(String[] args) {
	String str1 = "Happy"
	String str2 = "Birthday";
	System.out.println(str1 + " " + str2);

	printString)str1);
	printString(str);

클래스 정의 모델 : 인스턴스 구분에 필요한 정보를 갖게 하자.
구분자가 될 수 있는 정보는 보통 stirng 으로 이름이나 구분자

좋은 클래스 정의 후보를 위한 초기화 메소드

public void initAccount(String acc, String ss, int bal) {
	accNum = acc;
	ssNumber = ss;
	balance = bal;
}
	init 은 필수적이기 떄문에 생성자를 만들었따

public BankAccount(String acc, String ss, int bal){
	accNUm =acc;
	ssNumber = ss;
	balance = bal;
}
	BankAccount yoon = new BankAccount("값","값","값")
이런식으로 ( ) 가 들어가는 이유가 생성자를 부르기 떄문이다

컴파일러에 의해 자동 삽입되는 디톨트 생성자가 있기때문에
new BankAccount() 라고 값 입력없이 부를떄는 디폴트 생성자를 부르는 것이다.

클래스의 이름 규칙

클래스 이름의 첫 문자는 대문자로 시작한다.

둘 이상의 단어가 묶여서 하나의 이름을 이룰 때 새로 시자갛는 단어는 대문자로 한다
Circle + Point = CirclePoint

메소드와 변수의 이름 규칙

메소드 및 변수 이름의 첫 문자는 솜누자로 시작한다.
둘 잇아의 단어가 묶여서 하나의 이름을 이룰때 새로 시작하는 단어는 대문자로 한다.
Add + Your + Monet = addYourMonet

상수의 이름 규칙

상수의 이름은 모든 문자를 대문자로 구성한다

클래스 패스에 대한 내용을 볼게요

현재 디렉토리에 대한 이해

C:\Pack>

다른 위치로 클래스 파일을 옮겨버렸다.
이상태에서 실행을 하게 되면 실행은 된다.
하지만 AAA.를 읽기 위해선 같은 장소에 있어야 하는데 그곳에 없어서
실행오류가 나게 된다.

그러면 클래스 패스를 지정해주어야한다.
set classpath =;C:\Pack\MyClass
이렇게 적어주면 현재위치, MyClass 도 사용할 것이다.
현재 디렉토리 말고도 다른 디렉토리의 파일도 검색하여 실행해라.
이런뜻
절대 경로를 쓸수도 있고
상대경로를 쓸수도 있다. .\MyClass

클래스 패스를 고정시키는 방법
변수의 이름으로 classpath, 변수 값으로 경로 정보 전달하면 클래스 패스가 시스템 전체에 적용이 된다
하지만 좋은 방법이 아니므로, 이렇듯 클래스 패스를 고정시키는 일이
가능하다는 사실 정도만 알고 있자.

고정적으로 클래스 패스를 이용할 이유는 없다 같은 디렉토리에 쳐 두어라

패키지 선언이 필요한 상황의 연출
공간에서의 충돌
동일 이름의 클래스 파일은 같은 위치에 둘 수 없다
접근 방법에서의 충돌
인스턴스 생성 방법에서 두 클래스에 차이가 없다.

공간적, 접근적 충돌 해결을 위한 패키지 선언

클래스 접근 방법의 구분
두개의 CIrcle.java
package co,.wxfx.smart
패키지 이름은 모두 소문자로 구정
인터넷 도메인 이름으 ㅣ역순으로 이름을 구성
이름 끝에 클래스를 정의한 주체 또는 팀의 이름 추가
com.wxfx.smart.Circle c1 = new com.wxfx.mart.Circle(3.5);

패키지 전체에 대한 import 선언
import com.wxfx.smart

정보 은닉
정보 은닉을 왜 해야되냐

class Circle {
	double rad = 0;
	final double PI = 3.14;
	
	public Circle(double r) {
		setRad(r);
	}

	public void setRad(double r) {
		if ( r < 0 ) {
			rad = 0;
			return;
		}
		rad = r;
	}

	public double getArea() {
		return (rad * rad) * PI;
	}
}

public		누구든 가능
protected	상속된 클래스 끼리만 접근 가능
private		정보 은닉, 클래스 안에서만 접근 가능
default		동일 패키지로 묶인 클래스 내에서만 접근 가능

상속에 대한 약간의 설명 : protected 선언의 의미 이해를 위한

public class ZZZ extends AAA {
	public void init(int n) {
		num = m; // 상속된 변수 num의 접근!
	}
}

public class AAA {
	protected int num;
}
		protected 선언으로 인해 상속 관계에서 접근,
		가능 동일 패키지로 묶이지 않았어도 상속되어있기 떄문

인스턴스 멤버 대상 접근 수준 지시자 정리
