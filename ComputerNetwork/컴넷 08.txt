TCP

point-to-point
	one sender, one receiver

reliable, in-order

pipelined

connection oriented

flow controlled

--------------------------------
TCP segment structure

개념만 이해하고 넘어가도록 합시다.

----------------------------------
TCP seq. numbers, ACKs

	window size
	v	  v
[][][][][][][][][][][][][][][][][][][][][][][]][
	^     ^
      next_base
               next_seq


--------------------------------
Time out은 어떻게 결정되는가?

-------------------------------
TCP ACK generation	[TCP 정리] *****

receiver쪽에서의 event			
1. 순서에 맞는(기다리고있던) 세그먼트가 도착한 경우, 뿐만 아니라
기다리고 있던 모든 데이터와 세그먼트가 ACKed된 경우
2. 기다리고 있던 순서에 맞는 세그먼트는 도착했는데 한가지 세그먼트가 ACK pending을 가짐[보류]
3.

TCP receiver action
1. delayed ACK,[우리가 알던 ACK은 즉각 응답이었으나 delayed ACK이 등장] 
500ms 정도 기다리다가 next segment가 오지않으면 ACK send
2. 즉시 cumulative ACK를 보냄. [순서적인 세그먼트를 가지고 ACKing(수신응답) 함]
3.


>>> 

다음 세그먼트가 있을 경우 사실 ACK를 매번 보낼 필요가 없어짐
ACK delay를 주어 일부러 느리게 줌
순서가 바뀐경우 ACK를 재전송하면 원래순서의 데이터를 받을 수 있음


이벤트 1
기다리는 순서번호를 가진 '순서가 맞는' 세그먼트의 도착, 기다리는 순서번호까지의 모든 데이터들은 
이미 확인응답 됨

TCP수신자 동작 1
지연된 ACK. 또 다른 '순서가 맞는' 세그먼트의 도착을 위해 500msec까지 기다린다. 
만약 다음 '순서에 맞는' 세그먼트가 이 기간에 도착하지 않으면, ACK를 보낸다.

이벤트 2
기다리는 순서번호를 가진 '순서가 맞는' 세그먼트의 도착. ACK 전송을 기다리는 
다른 하나의 '순서에 맞는' 세그먼트가 있음

TCP수신자 동작 2
즉시 2개의 '순서가 맞는' 세그먼트들을 ACK하기 위해, 하나의 누적된 ACK를 보낸다.

이벤트 3
기다리는 것보다 높은 순서번호를 가진 '순서가 틀린' 세그먼트의 도착. 격차가 발견됨.

TCP수신자 동작 3
즉시 순서번호가 다음의 기다리는 바이트(즉, 격차의 최솟값)를 나타내는 중복 ACK를 보낸다. 

이벤트 4
수신 데이터에서 격차를 부분적으로 또는 모두 채우는 세그먼트의 도착

TCP수신자 동작 4
즉시, ACK를 보낸다. 단, 그 세그먼트가 격차의 최솟값에서 시작한다고 가정. 