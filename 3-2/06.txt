시스템소프트웨어실습

파이프

프로세스 간 통신에 사용된다.
실행되고 있는 프로세스 간 데이터를 공유하고 주고받는 방식 [프로세스 사이에 채널이 있음]

파이프 함수
pipe()
dup()
dup2()

지명 파이프

지명 파이프 함수
mkfifo 명령어
mkfifo()

프로세스 간 통신
IPC (인터 프로세스 커뮤니케이션)
프로셋들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로
주요 IPC 방식
파일 (file)
시그널 (signal)
파이프 (pip)	공유메모리
메시지 큐		ㄱㅇㅁㅁㄹ
지명 파이프	ㄱㅇㅁㅁㄹ
공유 메모리	ㄱㅇㅁㅁㄹ
세마포어		네트워크
소켓		ㄴㅌㅇㅋ

개인적으로 공부를 많이해야할 필요가 있을 수도 있다.
시스템 프로그램에서 핵심적인 부분이다.
비단 파이프 뿐만 아니라 모든 내용들이

전송 프로세스 			channel			받는 프로세스
		       프로세스와 프로세스를 연결하는 채널
-----------------------------------------------------------------------------------------------
파이프
	파이프는 프로세스 간 통신을 위한 메커니즘
	프로세스의 데이터 흐름을 다른 프로세스로 연결할 때 사용함.
		주로, 한 프로세스의 출력을 다른 프로세스의 입력으로 연결하는 경우에 사용함
	동일한 부모 프로세스로부터 생성된 자식 프로세스 사이에서만 사용 가능함

	파이프는 익명 파이프라고도 함

	파이프는 프로세스 사이에 형식이 없는 (언스트럭쳐) 데이터 교환을 가능하게함
	파이프를 통해 전달되는 데이터는 단순한 바이트 스트림 형태
								[데이터 형이 없다]
	파이프는 고정된 크기(용량)을 갖음
	파이프는 한쪽 방향으로만 통신이 가능하고 반이중 통신 방식임
	하나의 프로세스는 읽기만 가능하고, 다른 프로세스는 쓰기만 가능함
								[동시에 주고 받을 순 없음]
	
	ls | sort

	외부에서도 접근 할 수 있는 것은 지명 파이프라고 하겠죠
	
	데이터 형식에 구애받지 않는다.


Process_1(1) 	->write->	pipe	 	->read->		Process_2(0) 
쓰기전용								읽기전용

양방향 통신시 2개의 파이프를 만들어야 한다.
Process_1(1) 	>-write->	pipe1		 >-read->		Process_2(0)
Process_1(0)	<-read<-		pipe2		<-write<-		Process_2(1)

--------------------------------------------------------------------------------------------------
파이프 함수

int pipe(int filedes[2]);	// 인자 : 파일 디스크립터 두개
			// 0번쨰에는 읽기를 위한 지시자(fd1)
			// 1번째에는 쓰기를 위한 지시자(fd2)
	프로세스간 통신을 할 수 있는 파이프 생성
	성공시 0, 오류시 -1

	fork() 사용시
	부모, 자식이 같은 곳을 가리킬때 굳이 파이프를 더 만들 필요는 없다.

	차일드에서 쓴 내용을 부모로 전달할 수 있다.
	파일디스크립터 경로를 통해서


	읽기 전용, 쓰기 전용 > 잘 이해해야 한다.
	pipefd[0] > 읽기전용	close(pipefd[1]) 을 함으로써 읽기전용으로만 이용
	pipefd[1] > 쓰기전용	close(pipefd[0]) 을 함으로써 쓰기전용으로만 이용

	pipe() 함수 예시

	int pipefd[2] = {0, }; 
	if (pipe(pipefd) == -1) { 에러 } ; // 파이프 생성
	pid_t pid = fork;
	if (pid == 0) // 자식 프로세스면 {
		close(pipefd[0]);	// 읽기 전용 fd 닫고 쓰기전용으로 이용
		write(pipefd[1], (int *)&num, sizeof(int));	파이프에 num 데이터 write
		close(pipefd[1]);	// 쓰기 전용 fd 닫고 종료
	}
	else	// 부모프로세스면 {
		close(pipefd[1]);	// 쓰기 전용 fd 닫고 읽기전용으로 이용
		read(pipefd[0], (int *)&num, sizeof(int));	파이프에 있는 num 데이터 read
		printf("%d", num);
		close(pipefd[0]);	// 읽기 전용 fd 닫고 종료		
	}

*Open file descriptor table
FD : 0	STDIN
FD : 1	STDOUT
FD : 2	STDERR		// 위 0,1,2 FD 는 기본적으로 설정 열려있음
FD : 3	pipefd[0]
FD : 4	pipefd[1]		// 생성한 파이프용 파일 디스크립터 0은 읽기전용, 1은 쓰기전용

dup() 함수
	파일 지시자를 복사함
	duplicate
	안쓰고 있는 값을 준다
	int dup(int oldfd)	// 인자 : 복사할 파일 지시자
	파일 읽기-쓰기 포인터(offset), 플래그 등을 공유함

	복사된 새 파일 지시자 반환
	int fd1 = 0;
	int fd2 = 0;
	fd1 = open("./a.txt", O_CREAT | O_RDWR, 0644);
	fd2 = dup(fd1);	//fd2 에 fd1의 파일 지시자 정보를 복사함 [mode, offset, 플래그 등]

dup2()
	파일 지시자를 지정한 새 파일 지시자로 복사함
	int dup2(int oldfd, int newfd); // 복사할 파일 지시자  새 파일 지시자
	반환 - 복사된 새 파일 지시자

	int pipefd[2] = {0, }; //파이프용 fd 두개 생성
	dup2(pipefd[1], STDOUT_FILENO);	// 쓰기전용 fd를 STDOUT_FILENO 에 복사 [기본 출력 모드에]
					// 반환은 STDOUT_FILENO
	execl("/bin/ls", "ls", "-a", "-l", NULL);	// 기본 출력 모드에 쓰기전용 fd가 붙어 execl 이 write됨

	STDOUT_FILENO 에 pipefd[1]의 역할 복사

	dup2(pipefd[0], STDIN_FILENO);	// 읽기전용 fd를 STDIN_FILENO에 복사	[기본 입력 모드에]
					// 쓰기전용에서 저장된 STDIN_FILENO 읽어옴 (읽기전용으로)
	execl("/usr/bin/sort", "sort", "-r", NULL);// 기본 입력모드에서 STDOUT_FILENO의 내용과 결합됨



	ls -al | sort -r
	
	ls -al 결과를 sort 로 넘겨주는 거잖아요
	이거를 구현할 수 있다.

	pipefd 를 만들고
	fork 로 자식, 부모를 나누고

	자식일때는 읽기 채널을 닫는다.
	1번채널 - 쓰기채널
	0번채널 - 읽기채널

	dup2(pipefd[1], STDOUT_FILEND);
	쓰기 채널 파일 지시자를 STDOUT 파일 지시자로 복사

	pipe함수쓰면 읽기, 쓰기 두개가 나오죠
	fork 하면 두개가 더 생기죠
	그 총 4개는 같은 파일 테이블을 공유하는데
	자식에서는 쓰기를 STDOUT 으로 바꿔주고
	부모에서는 읽기를 STDIN으로 바꿔준다

	그니깐 FD : 0 에 pipefd[0] 이 들어가고
	FD:1 에 pipefd[1]이 들어간다.

	우리가 쓴 메모리를 가져올수 있다.

	child 에서 메모리에 wrtie하고 wait가 끝나면 parent에서 메모리에 쓰여진 것을 읽어온다.

---------------------------------------------------------------------------------------------------
지명 파이프에 대한 내용 진행하도록 하겠습니다.

지명 파이프는 프로세스 간 통신을 위한 메코니즘으로, 익명 파이프와 유사함
>익명 파이프는 부모와 자식 프로세스 간에서만 사용 가능한 단점이 있음
>지명 파이프는 서로 다른 프로세스에서도 사용할 수 있음

POSIX에서 지명 파이프는 특수 파일로 분류되고, 관리됨

지명 파이프는 일반 파일과 유사하게, 고유의 이름과 권한을 갖음

지명 파이프는 삭제되기 전까지 유지된다.

--------------------------------------------------------------------------
지명 파이프 함수 [서로 다른 프로세스 간 통신]  // (익명 파이프 [부모 - 자식 프로세스간 통신])

mkfifo 명령어
	지명 파이프를 생성하는 명령어
	mkfifo [경로]

mkfifo() 함수
	int mkfifo(const char* pathname, mode_t mode); // 경로(파일이름), 모드
	
	int main(int argc, char const*argv[]) { // main 실행시 값 읽어옴	argv[0] 은 실행파일
	
	mkfifo(argv[1], 0666)
		666의 권한을 같는 argv[1] 에 입력된 파이프 생성

	buf > 데이터 옮기기전 잠깐 저장하는 휘발성 공간

	지명 파이프 예시 - 서버
		          - 클라이언트
   fifo 이용한 서버
	int fd = 0;
	char buf[32 + 1] = { 0x00, };

	mkfifo(argv[1], 0666);	// 프로그램 실행시 입력한 argv[1] 이름의 666권한을 갖는 지명파이프생성
	fd = open(argv[1], O_RDONLY);	// 지명파이프 read 권한으로 오픈
	while(1) {
		if (read(fd, (char *)buf, 32 + 1) > 0) {	// read가 성공적으로 불어오고 끝이 아니면
			puts(buf);		buf에 저장한 내용 출력
			memset(buf, 0x00, 32 +1); 	// buf 내용 다시 0으로 초기화 (버프 비우기)
		}
	}
	return 0;
	}

   fifo 이용한 클라이언트
	int num = 0;
	int fd = 0;
	fd = open(argv[1], O_WRONLY);	지명파이프 argv[1] 쓰기권한으로 실행
	dup2(fd, STDOUT_FILENO);		argv[1] 파일을 기본 출력과 연결 [출력 내용은 argv[1]으로 출력]
	
	while(1)	{
		num = 123;
		printf("%d, %d", getpid(), num);	// 화면에 출력되는 것이아니고 argv[1] 파이프로 출력]
		fflush(stdout);	// 출력버퍼 비움
		}
	close(fd);
	
	return 0;
	}

	dup2(fd, STDOUT_FILENO); 을 이용해
	화면에 출력될 내용을 fd와 연결된 파일로 연결함
	파이프에 담긴내용은 다른 프로세서에서도 접근 가능

	파이프를 이용한 서버 구현
	


