디렉토리의 구현

디렉토리 엔트리

linear list 선형 리스트 ( 어떠한 형태를 가지고 있는 리스트)

creating a new file

deleting aa file


디렉토리 안에 있는 디렉토리 엔트리를 접근하고 싶으면
우선 디레고리를 오픈해야한다.

오픈하고 싶으면
openddir(패쓰네임) 을 사용한다

regular, device, 소켓, fifo

open; read; write; close 를 이용하는데

디렉토리 경우에는 opendir 가 따로 있는 것이다
다른 함수들과 여기서 차이점이 있다.

성공, 실패시 반환값이 1,0 이있었다
하지만 디렉토리 함수는 실패하면 NULL 을 반환하고 성공하면 NULL 이외의 값을 반환하게 된다.

fiel descriptro 는 파일 변수와 다르게 오픈한 디렉토리를 지정하기 위해 사용된다.

디렉토리를 오픈했으면 디렉토리안에있는 내용 읽어야겠죠

읽는 방법은 readdir 함수를 사용하게되요

오픈때받은 디렉토리 포인터를 인자로 받게되요

리턴되는 값은 디렉토리 엔트리의 주소를 담은 주소값을 리턴하게 되요

이것을 작동하려면 while 문에 코드를 담아야 해요

그 이유는 처음 readdir 을 실행하게되면 제일 첫번째에 있는 값을 읽고
그 다음 엔트리를 읽고 또 그다음 엔트리를 읽게되고
그렇게 계속 디렉토리 파일에 대한 엔트리를 읽ㄹ다가 EOF를 만나게되면
null 값을 리턴하게 된다,
즉 null값을 리턴하게 되면 eof를 만났고 즉 끝에 도달했다는 듰이에요
그니깐 모든 엔트리를 다 돌아보기 위해서 while문에 값을 넣게 되는 거에요

구조체를 불러와야되요 구조체 안에 엔트리 안에 있는 것을 불러오게되요
구조체 파일, 포인터, 오프셋 등을 불러오게 되요
readdir 을 불러오면 그 주소값을 불러오게 되고 파일안에 주소값을 이용해서
리텍토리의 정보가 불러오게 되요
즉 whilel 문안에서 이런 코드 패턴으로 모든 값을 불러올 수 있다는 거에요

즉 이제 모든 디렉토리 값을 읽었다 더이상 읽고 싶지 않고 하면 closedir 을 이용하게 되요
open, read, close 함수 대신
opendir, readdir, closedir 함수를 사용하게 된다는 것을 잘기억해주면 되겠습니다.

mkdir 함수를 사용하게 되묜
오너가 쓰고 읽고 시행할 수 있도록 켜지게 된다

mkdir 실행시 동일한 이름이 있는지 검사하게 되고 있으면 오류, 없으면 파일 하나를 만들게 될거에요
이런 식으로 디렉토리 파일을 하나 만들수 있답니다.
open(패쓰네임, 크리에이트) 이런식을 만드는 거와 비슷한거에요
결국에는 다시 돌아와서 readdir을 하게되면 파일 정보를 받아서 구조체 안에 d+ino 안에 넣게 되고
그 값을 불러오는 거에요
그니깐 메모리를 할당 받지 않ㅇ아도 되요ㅕ
그냥 구조체에 값을 저장해주는거에요
그래서 무조건 포인터가 들어가야되고 주소값을 받아서 구조체에 저장해야되는 거에요
그것이 디렉토리를 열고 사용ㅎ고 그런 식으로 하는 거에요

말록을 사용해서 메모리 공간을 할당하는 것이 아니에여
여러분은 단지 포인터만 사용해서 리턴값을 이용하면 되는거에요

unlink 함수를 이용해서 디렉토리를 삭제하는것이에요 rmdir() 함수도 있긴해요
unlink(패쓰네임) 이런식으로 사용하는 거에요

우선 삭제하고자 하는 파일이 디렉토리에 있는지 확인하고 있으면 싹! 삭제해버려요
그런데 만약에 여러분이 foo.txt 를 삭제하고 싶다. 그리고 foo.txt 이 1G regular 파일이다
그러면 멈ㄴ저 찾아요
그리고 디렉토리 형태만 날려버리고 파일은 삭제하지않아요
대신에 메모리 상에 남아있는데 그 파일을 사용하지 않는 상태로 남겨버려요
아무리 큰 파일이어도 삭제하는 시간이 굉장히 짧아요
왜냐면 메모리 자체에서 깨끗하게 청소하는 것이아니고 그냥 엔트리 자체에서 날려버리기때문에
그 존재만 까먹게 하는 것이에요. 실제로 메모리상에서 삭제하는 함수가 아니에요 그래서 unlink 라고해요

-------------------------------------------------------------------------------------------------
이제 스탠다드 i/o 함수에 대해서 배워볼게요
fopen fcloser
fread fwrite
뭐 이딴 함수들이 있어요

유닉스 io 펑션에서 open read write lseek stat close 이런 함수들은 배웠어요
유닉스 펑션을 사용할 수있고
스탠다드 io 펑션을 사용할 수 있어요

근데 어려분들은 standart io 펑션을 사용하는 것이 더 편해요
FILE *fp = fopen("a.txt", "rwx")
뭐 이렇게 열때 리턴되는 값은 stream 이에요

이 스트림은 내부적으로 파일 디스크립터와 버퍼를 가지고 있어요

그래서 여러분들은 stdin stdout stderr 를 자동으로 오픈하게 도요
stdio.h 에 이미 들어가 이는거에요

우리가 아까전에 본것처럼
fp = fopen("a.txt", "rw");
fp 는 stream 이에요
내부적으로는 파일이라는 구조체를 하나 만들어요
그리고 a.txt 를 만들었겠죠
그리고 메모리 상에서 malloc으로 버퍼를 하나 만들어요ㅕ
글리고 a.txt를 오픈해요
그러면 파일 디스크립터가 오픈되겠죠
3번 디스크립터를 파일 구조체안에 저장하게 되용
그러면 fopen이 완성되는 거에용
이제 구조체의 시작포인터를 return 하게 되는거에요

즉 스트림은 파일 구조체의 포인터에 저장된다고 보면되는 겁니다.

fwrite myopen 에 저장되어있는 글자가 버퍼에 저장되는거에요

여기서 주의할 것은 fwrite 를해서 파일에 저장한다
이때 메모리안에서만 저장하고 wrtie를 호출하잖아요??
이러면 a.t.xt에 저장되지 않고 internet buffer 로만 저장되고 파일에 저장되지 않아요
그러면 어떻게 파일에 저장할것이냐?
메모리에 저장된 것을 카피할것이에요

버퍼링 인 스탠다드 아이오
그것을 버퍼링이라고 합니다
버퍼링을 사용학 되면 사용자가 fwrite를 통해서 저장할때 차곡차곡 쌓이게 될거에요
버퍼가 full이 되면 a.txt 에 저장하게 되는거에요

그러면 문제가 무엇이냐
여러분이 데이터를 채우고 있어요
그러다가 시스템이 전원이 나가버렸어요
메모리 상에 있는 버퍼가 저장이 안되기때문에
fflush라는 함수를 만들었어요
큰 손실을 막기위해서
강제적으로 버퍼에 있는 메모리를 디스크에 저장하고싶으면 fflush 함수를 사용하면되요

flush? 버퍼에 있는 데이터를 디스크에 강제적으로 저장하라!
라는 뜻이에요

한가지더!
자 여기보면 봐요. 한가지 더가 아니고
버퍼안에 hello를 넣었어요
그리고 강제적으로 fflush를 한다
fflush(stdout)
강제적으로 터미널로 글자가 출력하게되요
이때 중요한것은 무엇이냐
fpriintf(stdout,
이때 stdout을 사용할때 > printf(와 똑같다
화면상으로 출력될 수도 있고 개행문자가 들어올때 화면상으로 글자를 출력합니다.
\n을 만나면 화면상에 글자를 출려갛게 되는거에요 즉 \n을 만나거나 버퍼가 꽉차야 파일로 데이터가
전달되는 거에요
파일에 출력되거나 화면에 출력되거나

단 스탠다드 아웃 스티림에 대해서 buffuer에 있는 데이터를 터미널로 출력한다
그리고 한가지만 더 언급할께요
여러분들 보면 
stdin stdout stderr 가 있는데
여기서 stderr라는 것을 여기서 버퍼를 가지고있잖아요
여기서 버퍼를 가지지않고 바로 화면상에서 출려갛게되요
그러니깐 급한 디버그 오류 메세지 이런것들은 stderr를 이용해서 출력하게 되는 거에요
버퍼에 저장하지 않고 바로 화면에 출력하는 것

프린트 a뒤에 오류가 나면 프린트 b가 날아가 버렸을수도 있어요
하지만 b에서 오류가 난것인데 말이죠
그것은 버퍼에 들어갔다가 없어지기 때문인데
stderr를 이용해서
바로 출력을 해버리면
오류난 시점인 b가 나오게 되는거에요
그러니깐 오류의 시점을 정확하게 알 수 있는 것이죠
이렇게 되면 디버깅이 좀 더 수월하게 될 것이에요


지금까지 유닉스 아이오와 스탠다드 아이오에 대해서 배웠어요
이것의 장점 및 단점이 무엇이냐
fopen 함수가 실행되고 open 함수를 수행할땐 프로그램이 부하가 이뤄질 수 있어요
stdio를 먼저 실행 > 부하가 가능하다
하지만 직접 unix 에서 실행하면 프로그램 부하가 적다
그리고 직접 접근할 수 있는 프로그램, 소프트웨어의 범위가 넓다고 할 수 있다.

하지만 버퍼링과 특정 코드를 추가해야되는 불편함이있다.
심각한 문제가 발생할 수도 있다.

스탠다드 아이오를 사용하게되면 사용자 편의성을 위한 함수이기 때문에 더 편하다
특정코드를 추가하지 않아도 함수만 이용해서 실행할 수 있는 편리함
하지만 메타데이터에 접근 할 수 없고 프로그램 과부하가 일어날 수 있다.
unix io 를 이용해서 네트워크 통신이 가능하지만 스탠다드 io를 통해서는 네트워크 통신이
불가능하다



