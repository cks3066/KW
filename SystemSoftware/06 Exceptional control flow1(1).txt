익셉셔널 컨트롤 플로우
예외적인 컨트롤 흐름
예외적인 통제 흐름
예외적인 관리 흐름


컨트롤 플로우

콤퓨터 안에 보면 cpu가 있어요
명렁어를 하나씩 순서대로 실행할것이에요
이떄 명령어의 실행 순서를 컨트롤 플로우라 그러고
또는 플로우 오프 컨트롤이라고해요

이떄 컨트롤 플로우가 뭔지 궁금할텐ㄷ데
intel amd 뭐 이런식으로 cpu제조 회사별로 컨트롤 플로우가 달라요

포인터를 배울때 흔히 사용하는 swap 함수를 
인텔 cpu명령어로 바꿨더니(즉 어셈블리)
어셈블리 형으로 나웠어요 하지만 이 형태는 회사별로 다르다는 것을 기억해야해요

이 실행순서를 컨트롤 플로욱라해요

실행순서가 차례대로 있는데 만약 내가 이것의 순서를 바꾸고 싶다면
어떻게 해아하는가
if문을 이용해서 데이터를 조작하면 되는 거에요 [go to문은 없다고 보면되요]
if문을 이용해서 jump 되는 것, 그리고 branch
jump가 go to 에요
실행순서를 바꾸는 것은 저런게 있다는 거에요

cpu에서 실행 상태가 변경됐다
예를 들어 0으로 숫자를 나눴거나, 컨트롤 c를 이용해서 강제 종료했다던가
이런 것들은 os에서 반응을해서 즉각적으로 실행 흐름을 바꾸게 되는거에요

그래서 다음 장으로 가게되면
예외석인 시스템변화

변화는 누가 발생하냐면 시스템 이벤트, os 형태로 실행흐름을 바꾸게 돼요
예외적으로

로우 레벨 머신(os, 사용자와 먼 본질적인 소프트웨어)
하이 레벨 머신에서는 시그널 등

어떤 이벤트가 발생했을때 (컨트롤 c, 오류, 0으로 나누기 등)
무한 루프를 돌고 있어도 내부적으로 이벤트에 대해서 os반응하게 되고
이때 os의 반응을 exception 하다고 해요
사용자 코드, 유저 코드 <> os 코드, 내부 코드
여러분들이 짠 프로세스가 돌아갈거에요
그때 이벤트가 발생하면 cpu는 예외적인 즉 exception 을 발생시켜요ㅕ
이떄 사용자코드에서 os코드로 바뀌는 것을 exceptional control flow 라고 하는 거게요

프로세스는
사용자에게 두가지 모습을 보여주는데
컴퓨터 프로그램이 cpu를 독점적으로 사용하는것처럼 보여주는것
무한대의 메모리를 독점적으로 사용하는 것처럼 보여준다

그래서 멀티테스킹이라는 것을 제공한다. 번갈아 가면서 사용하도록.
그리고 버츄어머신을 사용하게 된다

타임영역
프로세스 A	프로세스 B	프로세스 C
독점		독점		독점		로지컬=버츄어 (사용자가 느끼기에는)
-----------------------------------------------------------
실행				
		실행
실행						피지컬 CPU (되게 짧은 순간씩 나눠 실행) [실제론]
				실행

겹치게 존재하는 시점에 동시에 실행하게 되요(병렬적으로)
concurrent process = parallel 
서로 concurrent 하는 관계를 가진다고 하는거에요~

겹치는 순간이 없으면
sequential 하는 관계를 가진다고 해요

context switching [process]

프로세스에는 메인에 
와일문에
무한루프를 통해서 다른 프로그램에서 A와 B를 시행하라는 명령을 동시에 받았으면
서로 번갈아서 시행하게 된다 [사용자가 느끼기엔 동시에 시행되는 것같음]
A			
				B
A			
				B
A				
				B

사용자가 느끼기엔 순서가 없어보인다.  이 관계는 병렬적관계 concurrent 한 관계이다

프로세스의 메모리 공간은 0번째부터 무한대까지 갈때 그떄 각각의 코드와 데이터가 있습니ㅏㄷ.
어떠한 형태로 올라갈지는 메모리 상에 저장되어있어요

프로세스를 생성하는 과정에서 보겠습니다.

프로세스를 생성할때 하는 시스템콜은 fork이다.
reautn 0 - 자식 프로세스
chiled의 pid = 부모 프로세스

이거 어려워요
	부모와 자식
	부모 프로세스가 자식 프로세를 낳어요
	낳게되면 부모가 가지고있는 메모리와 코드를 자식이 상속 받는다.

	지역변수 x = 1 메모리에 저장
	pid_t pid = fork();
	if (pid == 0) { 	// pid가 0이라는 것은 무엇을 뜻하는가? return 0이 되면 자식 프로세스 이기
			때문에 pid값이 0이면 자식프로세스라는 뜻이다.
	이 밑은 자식 프로세스가 실행될 것이다.
	} else { 		// pid가 0이 아닌 다른 값을 가지고 있다는 것은 chile의 pid를 받은 (프로세스
			아이디) 부모 프로세스라는 뜻이다.
	이 곳은 부모 프로세스가 반영될 것이다.
	}

여기 부모가 이썽요
pid = fork() 를 통해서 자식을 생성하게 되요
그러면 child 프로세스가 만들어져요 그러면 자식은 부모의 코드와 메모리를 다 상속받게되요
child 속에 부모의 모든 것이 다 들어있다는 것
[부모 프로세스라는 것은 현재 fork() 함수가 불러진 그 함수 자체]
[내가 실행하고 있는 프로세스가 부모 프로세스]
[fork 전후로 부모가 되는지 안되는지가 나눠지는것]
[부모 프로세스에서는 변수 pid 의 값이 차일드 프로세스의 pid가 불러와지는 것이고]
[차일드의 코드속 pid 값은 0일 것이다]
이렇게 이해하면 되는것이다 쉽지? 쉽다고 느끼면 쉬울것이다 
어려울 것 하나도 없다
단지 그냥 fork 를 통해서 부모, 자식 프로세스가 형성 되는것이고
똑같은 두 프로세스에서 구별할 수 있는 방법이
그 코드속 pid의 값이 부모에서는 0이 아닌 다른 수고 child 프로세스의 pid값이 들어가고
child 의 pid 는 0이 할당,저장된다.

그러면 이번에 x값은 무엇일까요
코드와 메모리를 물려받는다고 했는데
처음에 선언한 x값은 무엇일까요
이전에 메모리상에 x값이 저장되어있었으니깐
부모가 물려준 그 저장된 x그대로 간다.

fork 하는 문을 보면
거의 무조건 if (pid == 0) 이런식으로 부모, 자식을 찾고 그 pid를 이용해섯 다른 시행을 하는 
그런 코드 패턴이 전형적이다.

그래서 중요한 것은 여기서 보면 포크하는 순간에 차일드로 포크 뿐만아니라 차일드로
그대로 복사한다
그리고 pid 값에 따라서 if else 문에 어디에 들어갈지가 저장된다.
fork 이전에 저장된 모든 값을도 차일드 프로세스에 들어간다.