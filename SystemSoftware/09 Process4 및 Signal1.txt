exec 에 대해서 좀 더 살펴볼게요

exec("패쓰",아규0,아규1,아규2,...,0);

패쓰는 cp를 가리킬 것이다.

cp.c 의 메인함수를 실행시킨다음에
다른 명령어를 수행한다.
cp.c의 명령어를 사용한다.

exec는 새로운 프로세스를 생성하는게 아니에요
기존의 값에 접근할 뿐입니다.

내부적으로 차일드를 포크하지 않기 때문이에요

exec Family 

execve
vector 에요
그러니깐 어레이에요
실행,벡터 함수
execve("패쓰",char *argv[]);
인자로 배열이 들어가요

비슷한것은 execvp 가 있어용
대신에
execvp("파일",char *argv[]);
패쓰가 아니라 파일이름이 들어가요

카피가 어디있는지 우리가 어떻게 알수 있냐?
알아서 찾을 거니깐 파일 이름만 적어라
대신 슬래시를 파일이름에 넣지말아라 햇갈리니깐
알긋냐~

exec 함수가 여렇게 있다는 것을 알아봤어요

그다음엔 Sysytem
system 함수가 있어요

main 함수에서
system("\usr\bin\cp foo bar")
명령어의 패쓰를 넣어줬어요
system("cp foo bar") 도 가능해요
usr\bin 에 들어있다면 > 여기서 찾을거니깐

wait(NULL); // waitpid(pid) 를 이용해서 child 가 끝날때까지 기다립니다.

이것이 system과 같은 형태입니다.

시스템을 사용하면 한개의 시스템콜로 원하는 바이너리를 실행할 수 있다는거에요

parent > child 
코드, 메모리 전부 물려준다 (카피한다)
open file 정보도 전부 넘겨준다.

parent 에서 a.txt b.txt 오픈
그 뒤
fork
자식도 물려바등ㅁ
write(fd1, pBuf, 512);
read(fd2, pBuf, 512);
오픈 한 파이로 그대로 물려받기 때문에 포크에서 오픈한 파일을 이리저리 조작할 수 있다.

부모의 디스크립터 테이블을 그대로 카피한다.
포인터로 가리키고 있는 오픈 파일 테이블을 그래도 가리키게 된다.
현제 몇개의 프로세스가 가리키고 있는지 나타내는 refcnt 라는 메모리 값이 있다.

프로세스에 대한 설명을 마치겠습니다.

예외적인 컨트롤 플로우 파트 2

시그널이 라는 것이 나와요
이것이 굉장히 어려운 파트 중 하나에요

시스템은 많은 프로세스를 동시에 시행하고 있어요
이런 동시에 시행되는 이런 프로세스를
동시에 진행되는것처럼 보이게 하기위해서
(cpu는 하나기 떄문에)
병렬적으로 잠깐잠깐씩 시행하게 된다.

번갈아가면서 실행하는 이것을 멀티태스킹

기본 함수
fork
exit
wait
execl
이런 함수를 시행한다.

본격적으로 시그널에 대해서 공부합시다.

어떤 이벤트가 시스템에서 일어났다는것을 알려주는 메세지이다.

event,interrupt,exception,error

cpu가 어떤 명령어를 시행하다가 os의 흐름으로 들어갔다가 다시 나오는것을 exception 이라고 했는데
cpu에서 오류때문에 에러가 발생하는 것 또한 exception 이라고 한다.

interrupt 와 exception 을 야기한 프로세스에게로 시그널이라는 것을 보내게 된다.
너때문에 니가 원하는, 니가 야기한 상황이 벌어졌다는 것을 알려주는 시그널을 보내게된다.

그러면 프로세스는 시그널을 receiving 하게 되고
다른 프로세스가 프로세스에게 sending 할 수 도 있다.

자 그래서 여기보면

이 표는 시그널 테이블이라고 할 수 있는데
시그널은 자신만의 이름이 테이블에 저장되어있어요
SIGINT,SIGKILL,SIGSEGVmSIGALRM,SIGCHILD 등등
2,9,11,14,17 로 자신만의 ID 번호가 이썽요
종료,종료,종료&덤프,종료,무시 이렇게 기본 액션이 있어요
그러고 원인이 있는데 왜 이 시그널이 왔는지 이유도 적혀있어요
컨트롤 c, 프로그램 kill , 세그멘테이션 바이올레이션(메모리 참조 오류), 타이머 시그널, 자식 죽었을때

main {
int *ptr;
*ptr = 100;
메모리를 할당받지 않고
이 값에 100이라는 숫자를 넣게되면
segmentation violation 혹은 fault 메세지를 보내고 종료되게 되요

이 오류를 막고 싶으면
malloc 으로 메모리를 할당해주면 되요

무한루프가 돌아가다가 컨트롤 c를 누르면
os는 SIGINT를 프로세스에게 전달해줄거에요
그뜻은 프로그램이 강제종료됐다는 뜻이고 id는 2이고 이러한 정보들을 전해주는게 시그널이에요

특정 목정을 가지고 특정 이벤트에 대해서 알려주는 것을 설정해놓은 것을 시그널이다.

num / 0 을 나누면 SIFFPE라는 시그널을 보내게 될것이고 이것은 계산의 연산이 잘 못되었을떄
보내는 시그널입니다.

이러한 에들이 있습니다.

kill 시스템 콜
parent, child 
fork 를 했겠죠
child 는 exit 함수를 이용해서 종료되었아요
이럴때 SIGCHILD 라는 시그널을 보내게되고 
기본액션은 ignore입니다. 무시하고 없애버립니다.









