System Level IO2

유닉스 파일에 대해서 알아볼게요

유닉스 파일이란 m 바이트로된 시퀀스에요
	B0,B1,...,Bk,...Bm-1   < 여기서 m-1 은 파일 오프셋 또는 포지션이라 그래요 file offset 또는position
모든 I/P 디바이스는 파일로 취급합니다.
	모든 디파이스는  유닉스 파일로 취급한다. 디스크 파티션, 터미널
컴퓨터가 사용하는 메모리도 유닉스 파일로 취급
커널 구조체 데이터도 유닉스 파일로 취급한다.

레귤러 파일(일반 파일)
	바이너리 혹은 텍스트 파일
	유닉스에서는 구분하지 않음
디렉토리 파일
디바이스 파일 ( 모든 디바이스를 파일 취급한다 그랬죠?)
	디바이스 파일에는 캐릭터 디바이스와 블록 디바이스가 있는데
	캐릭터 디바이스는 바이터 단위로 데이터를 교환하고 (키보드, 모니터)
	블록 디바이스는 (512B, 1KB, 등등) 등 특별한 데이터 단위로 데이터를 이동한다(디스크)
	컴퓨터와 디바이스간에 주고 받는 데이터가 1바이트가 아니기 때문에 블록데이터라고 한다.
피포 파일(FIFO) [named pipe]
	나중에 더 설명할 거에요` 인터프로세스 커뮤니케이션
소켓
	네트워크에서 배울거에요, 이 과목에서는 배우지 않아요. 인터넷이라고 생각하면 되요.
-------------------------------------------------------------------------------------------------
유닉스 I/O
	유닉스 아이오의 기본 철학은 각종 파일에서 read.write를 하고 싶을 때 여러개의 파일을
	작동, 동작하게 하는 함수들을 유닉스 I/O 라고 한다.
	파일의 종류에 관계없이 하나의 함수로 데이터를 읽고, 쓰고, 조작할 수 있다.
	-- 파일의 종류별로 서로 다른 함수를 가지고 있으면 불편할 수 밖에 없기 때문에 하나의 함수로
	통일하여 함수를 공유하는 것이다.
	> 적은 개수의 함수로 쉽게 조작할 수 있는 장점이 있다.
	> 파일의 종류가 다르더라도 동일한 작동을 한다.
-----------------------------------------------------------------------------------------------------
파일 오퍼레이션을 위한 시스템 콜
		
				어플리케이션 코드
User Process				ㅜ		ㅓ fopen, fclose, printf, fgetc, getchar
				C 라이브러리 함수
-------------				ㅜ		ㅓ open, close, read, write, seek [시스템 콜]]
Kernel				      파일 시스템

---------------------------------------------------------------------------------------------------------
파일 디스크립터 & 아이덴티티[ID]

파일 아이디
	파일을 구별하기 위한 ID 를 inode 넘버 라고 한다.
	아이노드
					각각의 파일 ID가 있고 그안에 파일 데이터가 있다.
					파일의 info ( 생성시간,유저, 퍼미션 등등)
					파일을 데이터를 이용하고 조작하고 싶다면
					무조건 open() 함수를 이용해서 파일을 불러와야한다.
					open() 함수를 call했을때 ID를 이용해 파일 데이터에 접근
					파일 데이터를 Memory(DRAM)으로 올려놓고 객체화시킴
					객체의 handle 또는 포인터, 주소 등을 반환함
					이떄 객체의 handle 또는 포인터, 주소를 
					파일 Descriptor 라고함 설명자

	즉, 파일을 조작하기위해 open 함수를 이용하여 메모리 상에서
	객체화 시켜 그것을 이용하기 위한 포인터, 주소, 핸들을 파일 디스크립터라고 한다.
	이말인 즉슨, open 함수를 이용해 불러오지 않은 파일은 파일 디스크립터가 존재할 수 없다.

-----------------------------------------------------------------------------------------------------------------
Opening FIles 열리는 파일들 [실패 다루는 법]

	오픈하는 함수는 이렇게 생겼다
	open('/etc/hosts', O_RDONLY)) < 0
	open(파일이름, 플래그)
	open 실패시 -1을 반환하게 된다. 
	실패할떄를 대비해서 
	if(open함수 < 0)
	perror("open")
	exit(1);
	이런식으로 에러 메세지 출력후 종료하는 이프문을 이용한다.
	
	이때 에러 원인을 확인해야 한다. 디버깅 목적으로
	perror 혹은 errno 을 이용하여 에러 원일을 파악하는데
	이것이 handling error 에러를 다루는 법이다.
	
	에러 다루는 법은 두가지 perror함수, errno 함수

	perror() 하면 에러 메시지를 출력하게 된다.
		왜 오픈이 안되었는지 이유를 화면상에 출력해줌. 그것을 보고 원일을 파악하면됨

	#include <errno.h> - 가장 최근발생한 에러 넘버를 errno 라는 변수 안에 저장함.
		printf("errno numer = %d : ", errno); 이런식으로 사용
		각 errno 의 숫자에 대한 에러원인이 저장되어있다.
		이것을 search 해서 에러의 원인을 파악하면 된다.

즉, 시스템 콜을 짤 때에는 에러핸들링을 하는 법을 이용하여 짜야한다.
대부분의 시스템콜은 fail시 -1을 반환한다. 아닌 경우도 있는데 차후에 수업하면서 설명해줄겡 ^^

------------------------------------------------------------------------------------------------------------
오픈 함수를 좀더 확실히 살펴볼게	
open(파일이름, 플래그) flag : O_RDONLY, O_WRONLY, O_RDWR [접근 모드] -access mode
			리드온리, 롸이트온리, 리드롸이트 [쓰기, 읽기에 대한 접근 권한을 주는것]
			웬만하면 RDWR 모드로 접근해라^^ 
		      flag : O_CREAT, O_EXCL [생성 모드] - creation mode
			크리에이트 exclusive [배제하는거야 파일 존재하는 경우를 오픈하지말고]
			CREAT  - 파일이 없으면 생성하여 오픈하고 있으면 그냥 오픈해라[기본값 RDWR]
			존재할때 삭제하고 다시 만들어오픈하는 것이 아니라 있으면 그냥 여는거야
			만약에 RDONLY로 열고 싶으면 open(파일이름, O_CREAT | O_RDONLY) 이렇게 
			쓰면된다.
			EXCL 은 혼자 사용될 수 없다. 무조건 CREAT와 | 를 이용해서 사용된다.
			만약 존재하지 않으면 생성하고 존재하면 -1을 출력하는 것이다.
			기본값 - 파일 존재시 그 파일 오픈
			excl - 파일 존재시 실패 -1 을 반환

-------------------------------------------------------------------------------------------------------------
클로징 파일 [ 파일 닫기]
close()함수
	close(파일 디스크립터)
	클로즈했는데 또 클로즈하거나 오픈안했는데 클로즈 하는 경우를 잘 생각해라
---------------------------------------------------------------------------------------------------------------
파일 포지션(오프셋)
	파일이 바이트 단위로 있을때 그 어느 위치에 있는 지 나타내는 것이 파일 오프셋이다

 - FIle "foo.txt" -

	file offset : 0	[	]   - 파일 시작
			[	]
			[	]                       ㅏ 1 byte
	file offset : 3	[	]
			[	]
			[	]   - EOF
----------------------------------------------------------------------------------------------------------------
파일 읽기
	파일에서 데이터를 읽어들이는 함수이다.
	ssize_t read(int fd, void* buf, size_t count)
		   (파일, 현재 위치, 얼마만큼)
	
	fd = open("a.txt", O_CREAT);
	// fd에 디스크립터가 들어간다.
	
	if (nbytes = read(fd, buf, sizeof(buf)) < 0) {
		perror("read");
		exit(1)
	}
	
	정상적으로 읽었으면 512바이트가 될거이다.  [512바이트 짜리 파일이면]

	fd = open() 을 했을때 첫 시작 current file offset 은 0에서 시작한다.
	요청한 사이즈가 sizeof(buf) 이기때문에 EOF 까지 가는 것.
	current file offset 은 read함수를 다 읽었으면 EOF 까지 갈 것이다. 즉 512
	
	이 다음에 read(fd, buf, sizeof(buf) 를 다시 해주면
	512에서 512로 가기때문에 0이 반환될것이다.

	버퍼 - 항아리에 담겨져있는 데이터를 퍼내기위한 물바가지
	버퍼 포인터 - 물바가지의 손잡이
	char buf[512] < 512 는 물을 담을수 있는 공간 (512) 씩 퍼냄

	OS는 data를 버퍼의 크기만큼 퍼 내서 담아줌
	
	데이터를 읽기위해서 버퍼를 만들어 내야 하는 이유이다.
	
	char buf[512] < 정적으로 만든 버퍼

	char* buf;
	buf =malloc(512); < 동적으로 만든 버퍼

	읽고자 하는 카운트보단 버퍼의 크기가 커야한다.
	바가지를 넘치는 양을 카운트 하면 안된다.
	read(fd, 버퍼, 카운트[읽을 양])

------------------------------------------------------------------------------------------------------------
파일 오프셋 과 버퍼
[update]
	char buf[4];

	fd = open("a.txt", O_CREAT);
	read(fd, buf, 4[바이트]);

	write(fd, buf, 4);

	read(fd, buf, 4);

	이렇게 했을때 a.txt
read	[R	]	current file offset : 0
	[R	]
	[R	]	
	[R	]	>
write	[W	]	current file offset : 4
	[W	]
	[W	]
	[W	]
	[W	]	>
read	[R	]	current file offset : 8
	[R	]
	[R	]
	[R	]	>
	[	]	current file offset : 12

	현재 파일 오프셋은 버퍼를 이용하는 함수 성공시 그 버퍼 만큼 이동하게 된다.

	current file offset 은 read, write 를 할때마다 update 된다.
	
	update 의 반대인게 append 라는 것이 있다.

----------------------------------------------------------------------------------------------------------------
[append]
	fd = open("a.txt", O_CREAT);
	read(fd, buf, 4[바이트]);

	write(fd, buf, 4);

	이렇게 했을때 a.txt => size : 4
read	0[R	]	current file offset : 0
	1[R	]
	2[R	]	
	3[R	]	current file offset : 4
			> 데이터가 없는 곳을 가리켰다.
write 를 어떻게 처리할 것인가?
	데이터를 추가한다.
	4[W	]
	5[W	]
	6[W	]
	7[W	]	current file offset : 8	
			>데이터가 없는 곳을 가리킨다.	

	append를 하여 파일의 크기를 계속 증가시킬수 있다.

	





	