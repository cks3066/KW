01 자료구조 Overview_DS

데이터 스트럭쳐라고 하는 것은 무엇일까

방금 전페이지에서 어떤 언급을 했냐면

프로그램은 데이터와 알고리즘이 결합된 형태

컴퓨터 프로그램이라 하는 것은 본질적으로 데이터를 다루고 있다

그 데이터를 어떻게 구조화 하느냐가 

데이터 스트럭쳐의 본질이라고 할 수 있다.

데이터의 덩어리로 부터 하고 싶은 것은

서치, 인서트, 딜레트. 업데이트

검색, 삽입, 삭제, 갱신

데이터 보관의 목적은 위의 4가지를 수행하기 위함이다.

이게 데이터 스트럭쳐의 본질이다.

이렇게 구조화 되지 않은 데이터를 구조화된 데이터로 만드는게 데이터 스트럭쳐의 본질이다.

구조화되지 않은 데이터로 부터 4가지를 수행하긴 어렵지만 구조화된 데이터로부터 하는 것은
보다 손쉽다.

내가 어떤 기능이 잘 수행되길 바라느냐에 따라서 다양한 종류이 스트럭쳐가 있을 수 있다.

서치 인서트 델리트 업데이트

4가지를 하는 것이 궁극의 목적이다.

일상생활에서 모방을 해서 스트럭쳐 구조화 모델을 가져오는 경우가 많다.

실생활 ex) 책 자체에서나 도서관에서 찾아볼 수 있는 [문헌정보학] INDEX

책에 있는 내용을 손쉽게 찾아볼수 있도록 기능을 가지고있다

처음부터 끝까지 읽지 않아도 원하는 내용이 어디에 있는지 찾아볼 수 있는 기능을 가지고 있다.

인덱스를 설정 > 구조화

책이 쌓여있으면 엉망진창이다. 중고서적에 가면 이렇게 있을텐데 이렇게 되어있으면

책을 찾기 힘들다. > 구조화가 필요하다

서치 인서트 딜레트 업데이트를 하기 위해서

도서관은 책의 주제별로 잘 분류가 되어있다. > 손쉽게 찾을 수 있도록 정리가 되어있다 ( 구조화가 되어 있다)

책에 번호를 붙이는 요령은 문헌정보학에서 배우는 내용이고 우리는 구조화에 집중한다.

이게 실행활에서 데이터가 어떻게 구조화되어 찾을 수 있느냐

책에서 이렇게 원하는 키워드를 찾는것처럼

컴퓨터에서도 손쉽게 찾고, 이용할 수 있도록 구조화하는 것

그것이 우리가 배우는 것이다. 그것이 "배움" 이니깐..

C++ 대부분의 자료구조를 라이브러리로 제공하고 있다.

STL(STRUCTURE LIBARARY)) 낮은 레벨의 STL 도 알려주겠다.

기본적인 내용의 STL 은 Array(static, dynamic) , vector(dynamic) 일반적으로 dynamic이 더 좋다.

multiset, set, stack, queue, priority queue, 

가장 좋은 데이터스트럭쳐가 있지만 교육적 목적으로 array, vector, list 등등으로 만들어 보겠다.

arraym list, heap, binary search tree, balanced BST, B-tree, Hash table

시간 복잡도 비교, 다음 페이지의 내용을 위해 간단하게 설명하겠다.

데이터의 개수에 따라 내가 사용하고 있는 데이터 스트럭쳐의 기능이 시간이 걸린다.

얼마나 시간이 걸리는지 > 시간 복잡도

logN 은 지수부분에 해당하는 시간

빨간색은 수행불가에 해당하는 부분이다.

시간복잡도에 대한 감을 가지고 있으면 데이터 사이즈가 어느정도 일때 수행가능한 수준인지 아닌지 

본인이 직접 판단할 수 있다. ( 물론 정확하진 않겠지만...)

sort라는 정렬 알고리즘을 예를 들어서
 
셀렉션 소트와 인서션 소트 알고리즘

array에서 binary heap으로 바꿨을때 시간복잡도가 O(n^2)에서 O(nlogn)으로 바뀐다.

시간을 엄청 효율적으로 사용할 수 있다.

정렬 알고리즘에 적절한 DS를 사용하는 것이 중요하다는 것을 알 수 있다.

효울적인 알고리즘이 어떠한 효과를 갖는지 알 수 있다.

프림의 알고리즘을 어떠한 자료구조로 해결하느냐에 따라 시간복잡도가 달라진다.

자료구조 시간에 배우진 않겠지만 좋은 Data Structure를 사용하는 것이 얼마나 효율적인지 보여주는 것 뿐이다.
			insert	delete	search
Array                          	1	n	n
List			1	n	n		
Heap			logn	logn	x
Bunart search tree		n	n	n
Balabced BST		logn	logn	logn	
B-tree			logn	logn	logn	
Hash table(perfect)		1	1	1   >  이상적으로 존재하는 것이지 현실적으로 존재하기 쉽지 않다.
Hash table(worst)		n	n	n

이에 대해서 inst delete search 의 시간을 비교할 수 있다.

각각의 DS가 어디서 쓰이는지 장단점이 뭔지 알고

적절히 사용하는 것이 중요하다. 그것을 익히는 것이 본 과목에 있는 내용이다.

중간중간 이 내용들을 계속 상기시키는 것이 좋을 것이다.

