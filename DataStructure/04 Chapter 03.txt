Chapter 03

컨테이너 클래스에 대한 진도를 나가겠습니다.

3장에서는 본격적인 자료구조의 틀을 알려주겠습니다.

3장에서 배우는 자료구조의 틀을 잘 익히면 괜찮을 것이다.

컨테이너 클래스 

도자기를 묶어서 쓰던 가방 모양

이상한 모자모양으로 띵킹캡을 정의했듯이 가방을 정의해 보겠다.

서치
인서트
업데이트
딜리트

이 것의 기본이 컨테이너 클래스이다.

컨테이너 클래스는 임플리멘티드 된다 함축된다 클래스 멤버함수들과 추가 제거 시험 아이템들을

3장은 두분은으로 나누어져있다.

클래스 껍데기에 대한 설명과 실제 구현에 대한 내용

껍데기의 이름은 Bag이라고 지었스비다.

가방이 어떤 역할을 하는 지 알아야 골격을 만들고 그 기능을 채울 수 있다.

가방안에는 숫자가 들어있다. 사실은 데이터 > 그냥 숫자라고 하겠다.

같은 숫자도 들어있다는 것을 알수 있다.

가방의 초기상태는 비어있을것이다.
(하지만 비어있는 가방이 더 무겁다.) > 물리현실을 생각하지 말아라.

그 다음 기능 > 가방에 숫자들을 넣을 수 있다.

나는 4라는 숫자를 가방에 넣고 있다.

4는 가방안에있습니다.

기쁜 마음에 엄지척을 했습니다.

이제 나는 다른 숫자인 숫자8을 가방에 넣고 있습니다.

8도 역시 가방안에 있습니다.

이제 나는 두번째 4를 가방안에 넣겠습니다.

가방에 대한 기능을 얘기하고 있습니다.

2장에서는 무엇을했나요? > 띵킹캡에 대해서 설명하고 골격을 만들고 구현에 들어갔죠ㅕ

오늘도 마찬가지로 백을 설명하고 골격을 만들고 구현에 들어가겠습니다. 그래서 기능을 설명하는 겁니다.

숫자들을 넣을 수 있고 심지어 같은 숫자도 넣을 수 있고 여러개를 넣을 수 있다.

세번째 기능을 알아보자

이그재미닝 백

가방을 검사하는 것

가방에 대해서 질문할 수 있다.

너 4있냐? 응 나 4두개 들고있어 ㅋㅋ

이런식으로 가방과 개화를 통해 가방안에 있는 숫자를 이그재미닝 할수 있다.

리무브도 가능하다.

번개표시가 나타나면 가방속에서 4가 삭제된다.

한가지 4는 없어졌으나 다른 4는 남아있다. 그러니깐 모든 4를 제거하는 것은 아니라는 뜻이다.

가방에 숫자를 넣고 삭제하고 검사하고 이딴 기능을 하는 가방을 만들어 볼 것이다.

how many numbers 가방에 숫자 몇개가 들어가있는지 셀 수 있어야한다.


백 오퍼레이션 요약
	가방은 초기상태로 비어있다.
	숫자들이 가방안에 들어갈 수 있다.
	특정한 숫자의 빈도수를 셀 수 있다. 같은 숫자가 몇개 있는지 확인할 수 있다.
	숫자를 삭제할 수 있다.
	가방에 숫자가 몇개 있는지 체크할 수 있다.

가방의 오퍼레이션을 요약했기 때문에 우리는 구현할 준비가 되어있다. 일단 껍데기를 만들어보자

class Bag
{
public:
	Bag();	// 생성자 a = 1, b = 2; 이딴거 해주는애
	void insert();
	void remove();
	size_t occurrences(int target) const
	size_t size() const;
private:
	we'll look at private members later. 우리는 프라이빗 멤버들을 나중에 살펴볼것이다.
};

bag::()
// 포스트컨디션 : 백은 초기화되어있다.
// 그리고 백은 비어있다.
{
... >private 데이터가 없어서 쓸 수가 엄서용
}

void bag::insert((int new_entry)
// 프리컨디션 : 가방이 꽉 차 있으면 안되용
// 포스트컨디션 : new_entry의 복사본이 가방에 추가되어야해용~ 콜바이벨류
{
...
}

int bag::size() const
// 포스트컨디션: 반환되는 값은 가방안에 있는 숫자의 갯수에용~
{
}

>>> 바꿔줄거에요 밑에있는 것 처러

#include <cstdlib>

std::size_t bag::szie() const
// 포스트컨디션: 반환되는 값은 가방안에 있는 숫자의 갯수에용~
{
...
}

	size_t 는 무엇이냐?
		unsigned int 이다. #define 으로 정의되어있다.
		음이아닌 정수에용~ 갯수니깐! 갯수는 이렇게 쓰는게 직관적이에요! 버그피하기도 좋고

std::size_t bag::occurrences(int target) const
// 포스트컨디션 : 반한되는 값은 가방 속 타켓의 복제 숫자의 갯수이다.
{
...
}

void bag::remove(int target)
//포스트컨디션: 만약 타켓이 가방에 있다면 하나의 복사본이 삭제되고 가방에 없다면 아무것도 변하지 않는다.
{
...
}



이제 바로 사용할 수 있다.

bag ages;

//Record the ages of three children:
ages.insert(4);
ages.insert(8);
ages.insert(4);
				> 애기들 나이를 넣었다. ㅋㅋ 쓸수이다 이제 작동은 안되겠지만 버튼은
				있다는거야

두개의 파일을 만들거에요
	bag1.h > 헤더파일
		다큐멘테이션 > 프로토타입과 스페시피케이션
			퍼블릭 멤버함수에 대한 설명이 거기이어야한다.
				프리컨디션, 포스트컨디션
					class Bags() {}; <<이거

	bag1.cpp > 구현코드
		멤버함수에 관계없이 클래스에 대한 임플리멘테이션들
		멤버함수들의 정의   void bag::bag() {} << 이거

영어에 대한 거부감이 없도록 해야한다.

추측해봐라 미스테리우스 베네펙터가 너한테 제공했다 Bag 클래스를, 하지만 오직 허용된다 읽는것만 
다큐멘테이션(헤더파일안에있는) 너는 읽을 수 없다 클래스 정의나 임프리멘테이션 파일을. 
너는 쓸수 있는가 한 프로그램을(가방 데이터형을 사용하는)

헤더파일안에 있는 다큐멘테이션만 보고 프로그램을 사용할 수 있는가?
> TV를 사고 메뉴얼만 보고 TV를 사용할 수 있는가?

> Yes, i can!


오늘은 골격만 만든 컨테이너 클래스를 구현하는 방법에 대해서 공부하도록 하겠습니다.

1주 뒤에 좆같은 과제를 내줄것이니 열심히 듣길 바란다.

알겠냐 이놈들아

가방을 만들어놓고 그 안에 숫자를 넣고 그 숫자를 삭제하거나 숫자가 몇개있는지 세거나 같은 숫자가

몇개 있는지 세거나 그런 지랄을 하기위해 클래스를 만들것이다.

이제 내가 구현을 어떻게 하는지 보여줄테니깐 너는 그냥 나를 따라하면서

잘 배우도록 하여라 

가방의 컨스트럭터는 이런 모습을 가지고있습니다.

class Bag
{
public:
	Bag();	// 생성자 a = 1, b = 2; 이딴거 해주는애
	void insert();
	void remove();
	size_t occurrences(int target) const
	size_t size() const;
private:
	we'll look at private members later. 우리는 프라이빗 멤버들을 나중에 살펴볼것이다.
};

bag::()
// 포스트컨디션 : 백은 초기화되어있다.
// 그리고 백은 비어있다.
{
... >private 데이터가 없어서 쓸 수가 엄서용
}

void bag::insert((int new_entry)
// 프리컨디션 : 가방이 꽉 차 있으면 안되용
// 포스트컨디션 : new_entry의 복사본이 가방에 추가되어야해용~ 콜바이벨류
{
...
}

int bag::size() const
// 포스트컨디션: 반환되는 값은 가방안에 있는 숫자의 갯수에용~
{
}

>>> 바꿔줄거에요 밑에있는 것 처러

#include <cstdlib>

std::size_t bag::szie() const
// 포스트컨디션: 반환되는 값은 가방안에 있는 숫자의 갯수에용~
{
...
}

	size_t 는 무엇이냐?
		unsigned int 이다. #define 으로 정의되어있다.
		음이아닌 정수에용~ 갯수니깐! 갯수는 이렇게 쓰는게 직관적이에요! 버그피하기도 좋고

std::size_t bag::occurrences(int target) const
// 포스트컨디션 : 반한되는 값은 가방 속 타켓의 복제 숫자의 갯수이다.
{
...
}

void bag::remove(int target)
//포스트컨디션: 만약 타켓이 가방에 있다면 하나의 복사본이 삭제되고 가방에 없다면 아무것도 변하지 않는다.
{
...
}


위에 쓰여져있는 것들이 저번에 만든 클래스의 골조이다.

오늘의 진도를 나가보겠습니다.

백클래스의 프라이빗 데이터 영역안에 데이터를 넣을 것이다.
가장 기본적인 데이터 스트럭쳐를 배웠을것이다. 그것은 바로 Array(배열)이다.
implementation Details
가방의 숫자들을 이용할 것이다.
적당한 사이즈의 배열을 만들어서 앞부분부터 채워가면서 배열을 이용할 것이다.
> 이것이 가방의 사이즈가 될 것이다.
여러분은 가방의 앞부분만 사용할 것이다.
[4][8][4][][][][][][][][][][][][][][][][][] < 이것이 배열의 모습일 것이다. 4,8과4가 들어가 있는 배열의 모습
가방안에 숫자가 들어가있는 것이 우리가 관심을 가져야할 중요한 모습이다.

아마 우리가 넣은 순서대로 들어가있을테지만 100% 그런것은 아니다.

몇개를 쓰고 있는지 트랙킹 하기 위한 변수가 하나 더 필요한거야.
size 라는 변수가 하나 있어야지 넣을때마다 그 변수를 하나씩 늘려가면서 데이터의 수를 파악할 수 있을
것이다. 이것은 size_t  이것을 데이터 형으로 사욯한다.

우리는 이 아이디어를 프라이빗 멤버 변수(bag class안에 함축될수 이 ㅆ는)를 쓰기 위해 사용할 것이다.



class Bag
{
public:
	static const size_t CAPACITY = 20;		// static 전역변수(공유한다)  const 상수
	Bag();	// 생성자 a = 1, b = 2; 이딴거 해주는애
	void insert();
	void remove();
	size_t occurrences(int target) const
	size_t size() const;
private:
	int data[CAPACITY];
	size_t used;
};

그러면 내가 private 변수에 대한 정답을 알아냈다면
5개 함수의 정의를 알아야겠죠

bag1.cpp---------

void bag::insert(int new_entry)                      
{
	assert(size() < CAPACITY);
 
	data[used++] = new_entry;
}

	------------------------------------------------- 아래와 같다.
	typedef int value_type;

	void bag::insert(const value_type& entry)
	{
		assert(size() < CAPACITY);
	
		data[used++] = entry;
	}


---------------------------------------------------------------------------------
bool bag::erase_one(const value_type& target)   //remove
{
	size_t index = 0;
	whie( (index < used) && (data[index] != target))
		++index;
	if(index==used)
		return false;
	--used;
	data[index] = data[used];
	return true;
}

-----------------------------------------------------------------------------------
#include <algorithm>
#include <cassert>

void bag::operator +=(const bag& addend) // 가방이 가방을 인자로 받을땐 private 접근 가능
{
	assert(size() +addend.size() <= CAPACITY);
	
	copy(addend.data, addend.data+addend.used,data+used);   
	// copy(복사할 시작위치, 복사 할 끝위치(복사되지않음), 복사될 곳의 시작위치)
	used += addend.used;
}

남은 내용은 책을 읽어봐라 ㅋㅋ

다른 종류의 책
	value 타입을 정의하고 value 타입을 바꿈으로써 int 타입 말고도 다른 타입으로 확장할 수 있다.







